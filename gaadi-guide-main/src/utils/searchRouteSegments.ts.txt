import { type IRoute } from "@/types/route.types";
import routes from "@/data/route_data.json";

interface GraphNode {
  stop: string;
  routeId: string;
  isTransfer?: boolean;
}

interface Graph {
  [key: string]: GraphNode[];
}

interface RouteSegment {
  id: string;
  name: string;
  lineColor: string;
  stops: string[];
}

interface SearchResult {
  segments: RouteSegment | RouteSegment[] | null;
  error: string | null;
}

async function searchRouteSegments(
  fromStopId: string,
  toStopId: string
): Promise<SearchResult> {
  try {
    // Load graph from public directory
    const response = await fetch("/graph.json");
    if (!response.ok) {
      throw new Error("Failed to load graph");
    }
    const graph: Graph = await response.json();

    // Validate inputs
    if (!fromStopId || !toStopId) {
      throw new Error("Start and destination stop IDs are required");
    }
    if (fromStopId === toStopId) {
      throw new Error("Start and destination cannot be the same");
    }
    if (!graph[fromStopId] || !graph[toStopId]) {
      throw new Error("Invalid stop IDs");
    }

    // BFS to find path maximizing stops per route
    const queue: {
      stop: string;
      path: { stop: string; routeId: string | null }[];
      currentRouteId: string | null;
    }[] = [
      {
        stop: fromStopId,
        path: [{ stop: fromStopId, routeId: null }],
        currentRouteId: null,
      },
    ];
    const visited = new Set([`${fromStopId}:null`]);

    while (queue.length) {
      const { stop, path, currentRouteId } = queue.shift()!;

      if (stop === toStopId) {
        // Build result with maximized segments
        const routeSegments: RouteSegment[] = [];
        let currentSegmentStops: string[] = [path[0].stop];
        let currentSegmentRouteId: string | null = null;

        for (let i = 1; i < path.length; i++) {
          const { stop: nextStop, routeId } = path[i];
          if (
            routeId !== currentSegmentRouteId &&
            currentSegmentRouteId !== null
          ) {
            const route = (routes as IRoute[]).find(
              (r) => r.id === currentSegmentRouteId
            );
            if (!route) {
              throw new Error(`Route ${currentSegmentRouteId} not found`);
            }
            routeSegments.push({
              id: route.id,
              name: route.name,
              lineColor: route.lineColor,
              stops: [...currentSegmentStops],
            });
            currentSegmentStops = [
              currentSegmentStops[currentSegmentStops.length - 1],
            ]; // Carry over last stop
          }
          currentSegmentRouteId = routeId;
          currentSegmentStops.push(nextStop);
        }

        // Add the last segment
        if (currentSegmentStops.length > 1) {
          const route = (routes as IRoute[]).find(
            (r) => r.id === currentSegmentRouteId
          );
          if (!route) {
            throw new Error(`Route ${currentSegmentRouteId} not found`);
          }
          routeSegments.push({
            id: route.id,
            name: route.name,
            lineColor: route.lineColor,
            stops: [...currentSegmentStops],
          });
        }

        // Ensure segments join properly
        for (let i = 0; i < routeSegments.length - 1; i++) {
          const currentSegment = routeSegments[i];
          const nextSegment = routeSegments[i + 1];
          if (
            currentSegment.stops[currentSegment.stops.length - 1] !==
            nextSegment.stops[0]
          ) {
            throw new Error("Segments do not join properly");
          }
        }

        return {
          segments:
            routeSegments.length === 1 ? routeSegments[0] : routeSegments,
          error: null,
        };
      }

      // Prioritize same routeId to maximize stops, then consider transfers
      const neighbors = graph[stop] || [];
      neighbors.sort((a, b) => {
        const aSameRoute = a.routeId === currentRouteId && !a.isTransfer;
        const bSameRoute = b.routeId === currentRouteId && !b.isTransfer;
        return aSameRoute === bSameRoute ? 0 : aSameRoute ? -1 : 1;
      });

      for (const neighbor of neighbors) {
        const { stop: nextStop, routeId, isTransfer } = neighbor;
        const key = `${nextStop}:${routeId || "null"}`;

        if (!visited.has(key)) {
          visited.add(key);
          queue.push({
            stop: nextStop,
            path: [...path, { stop: nextStop, routeId }],
            currentRouteId: routeId || currentRouteId,
          });
        }
      }
    }

    return { segments: null, error: "No route found" };
  } catch (error) {
    return { segments: null, error: (error as Error).message };
  }
}

export default searchRouteSegments;
